# CharacterNFT Storage Layout Documentation

## Overview

This document describes the storage layout of the CharacterNFT upgradeable contract using UUPS (Universal Upgradeable Proxy Standard). Understanding the storage layout is **critical** for safe upgrades.

## ⚠️ CRITICAL RULES FOR UPGRADES

1. **NEVER reorder existing state variables**
2. **NEVER change the type of existing variables**
3. **NEVER delete existing variables**
4. **ALWAYS add new variables AFTER existing ones**
5. **ALWAYS reduce __gap size when adding new variables**

## Current Storage Layout (v1.0.0)

### Inherited Storage (from OpenZeppelin)

**From Initializable:**
- Slot 0: `uint8 _initialized` + `bool _initializing`

**From ERC721Upgradeable:**
- Slot 1: `string _name`
- Slot 2: `string _symbol`
- Slot 3: `mapping(uint256 => address) _owners`
- Slot 4: `mapping(address => uint256) _balances`
- Slot 5: `mapping(uint256 => address) _tokenApprovals`
- Slot 6: `mapping(address => mapping(address => bool)) _operatorApprovals`
- Slots 7-56: `uint256[50] __gap` (ERC721 storage gap)

**From OwnableUpgradeable:**
- Slot 57: `address _owner`
- Slots 58-106: `uint256[49] __gap` (Ownable storage gap)

**From UUPSUpgradeable:**
- No additional storage (only functions)

### CharacterNFT Custom Storage

**Slot 107:** `LoveToken public loveToken`
- Address of the LOVE token contract
- Type: `LoveToken` (address internally)

**Slot 108:** `address public treasury`
- Treasury address for receiving minting fees
- Type: `address`

**Slot 109:** `uint256 public constant MINT_COST`
- Constant: Not stored in contract storage
- Value: 100 * 10^18 (100 LOVE)

**Slot 110:** `uint256 public constant TRANSFER_FEE`
- Constant: Not stored in contract storage
- Value: 50 * 10^18 (50 LOVE)

**Slot 111:** `uint256 private _nextTokenId`
- Counter for next token ID to mint
- Type: `uint256`

**Slot 112:** `mapping(uint256 => Character) private _characters`
- Mapping from token ID to Character struct
- Type: `mapping(uint256 => Character)`

### Character Struct Layout

The `Character` struct contains:
```solidity
struct Character {
    string name;                    // Slot 0 (dynamic)
    uint32 birthTimestamp;          // Slot 1 (packed) - Unix timestamp for astrology
    Gender gender;                  // Slot 1 (packed)
    SexualOrientation sexualOrientation; // Slot 1 (packed)
    uint8 occupationId;             // Slot 2 (packed)
    uint8 personalityId;            // Slot 2 (packed)
    Language language;              // Slot 2 (packed)
    uint256 mintedAt;               // Slot 3
    bool isBonded;                  // Slot 4 (packed)
    bytes32 secret;                 // Slot 5 (hidden personality trait)
}
```

**Note on `birthTimestamp` field:**
- Unix timestamp (uint32) representing exact birth date/time
- Generated relative to minting time: character is always 21-25 years old when minted
- Calculation: `block.timestamp - (21 to 25 years in seconds)`
- Used for astrology calculations (zodiac sign, moon sign, rising sign, etc.)
- As time passes, characters minted later will have later birth dates (always current - 21-25 years)

**Note on `secret` field:**
- Randomly generated bytes32 hash during minting
- Provides thousands of unique hidden personality traits for AI agents
- Not intended to be revealed to players in the UI
- Allows AI personality depth beyond visible attributes

**Slot 113-162:** `uint256[50] private __gap`
- Reserved storage gap for future state variables
- **CRITICAL:** Reduce this when adding new variables

## Total Storage Slots Used

- OpenZeppelin: Slots 0-106 (107 slots)
- CharacterNFT: Slots 107-162 (56 slots, including 50-slot gap)
- **Total Reserved:** 163 slots

## How to Add New State Variables (Example)

### ❌ WRONG - Will break existing storage!

```solidity
contract CharacterNFT_V2 {
    // DON'T DO THIS!
    uint256 public newFeature;      // ❌ Inserted before existing
    LoveToken public loveToken;     // ❌ Shifted to wrong slot!
    address public treasury;        // ❌ Shifted to wrong slot!
    // ... rest of variables
}
```

### ✅ CORRECT - Preserves storage layout

```solidity
contract CharacterNFT_V2 {
    // Keep ALL existing variables in EXACT same order
    LoveToken public loveToken;              // Slot 107 ✅
    address public treasury;                 // Slot 108 ✅
    uint256 private _nextTokenId;             // Slot 111 ✅
    mapping(uint256 => Character) private _characters; // Slot 112 ✅

    // Add NEW variables AFTER all existing ones
    uint256 public newFeature1;               // Slot 113 ✅
    mapping(address => bool) public newFeature2; // Slot 114 ✅

    // Reduce gap by number of new variables added (2 in this case)
    uint256[48] private __gap;  // Was 50, now 48 ✅
}
```

## Enum Definitions

```solidity
enum Gender {
    Male,       // 0
    Female,     // 1
    NonBinary   // 2
}

enum SexualOrientation {
    Straight,   // 0
    SameGender, // 1
    Bisexual,   // 2
    Pansexual,  // 3
    Asexual     // 4
}

enum Language {
    EN  // 0
}
```

**Note:** Enums are stored as `uint8` internally and can be expanded (add new values at end) but never modified/reordered.

## Constants (Not in Storage)

These are compile-time constants and don't occupy storage slots:

- `MINT_COST = 100 * 10**18` (100 LOVE)
- `TRANSFER_FEE = 50 * 10**18` (50 LOVE)
- `OCCUPATION_COUNT = 10`
- `PERSONALITY_COUNT = 10`

## Upgrade Checklist

Before deploying an upgrade:

- [ ] All existing variables are in the same order
- [ ] No variables removed or reordered
- [ ] New variables added AFTER existing ones
- [ ] Storage gap reduced by number of new variables
- [ ] No type changes to existing variables
- [ ] Enums only have new values appended (if modified)
- [ ] Run `npx hardhat test` to verify storage compatibility
- [ ] Use OpenZeppelin's storage layout checker:
  ```bash
  npx hardhat verify --network baseSepolia <implementation-address>
  ```

## Storage Validation Tool

Use OpenZeppelin's Upgrades plugin to validate storage safety:

```typescript
// In your upgrade script
import { upgrades } from "hardhat";

// This will fail if storage layout is incompatible
await upgrades.upgradeProxy(proxyAddress, CharacterNFT_V2);
```

The plugin checks:
- ✅ No variables deleted
- ✅ No variables reordered
- ✅ No type changes
- ✅ New variables only at end
- ⚠️ Warns about gap changes

## Version History

### v1.0.0 (Current - Pre-Deployment)
- Initial UUPS upgradeable implementation
- Character NFT with bonding mechanism
- Secret personality trait (bytes32 hash for AI personality depth)
- 50-slot storage gap reserved

**Character Attributes:**
- Player-selected: name, gender, sexualOrientation, language
- Randomized: birthTimestamp, occupationId, personalityId, secret
- Gameplay: isBonded, mintedAt

### Future Versions
- Document storage changes here
- List which gap slots are used
- Explain why changes were made

## References

- [OpenZeppelin Upgrades Documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable)
- [UUPS Pattern](https://eips.ethereum.org/EIPS/eip-1822)
- [Storage Gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)

## Contact

For questions about storage layout or upgrades, consult the development team before making changes.

---

**Last Updated:** 2025-10-15
**Version:** 1.0.0
**Network:** Base Sepolia (Testnet)
